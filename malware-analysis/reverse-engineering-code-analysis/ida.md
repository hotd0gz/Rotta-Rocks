# IDA



## Introduction





<figure><img src="../../.gitbook/assets/image (60).png" alt=""><figcaption></figcaption></figure>

## Graph & Text Views

The default view is the Graph View which we see above. If you press spacebar IDA switches between views

<figure><img src="../../.gitbook/assets/image (61).png" alt="" width="563"><figcaption><p>Text View</p></figcaption></figure>



## Functions

Each function is displayed as a node in the graph view. Below I've highlighted the functions starting the the "start (1)" function.

<figure><img src="../../.gitbook/assets/image (62).png" alt=""><figcaption></figcaption></figure>

IDA's Text View employs arrows for different conditional jumps and control flow.

* <mark style="color:yellow;">`Solid Arrow (→)`</mark>: A solid arrow denotes a direct jump or branch instruction, indicating an unconditional shift in the program's flow where execution moves from one location to another. This occurs when a jump or branch instruction like `jmp` or `call` is encountered.
* <mark style="color:yellow;">`Dashed Arrow (---→)`</mark>: A dashed arrow represents a conditional jump or branch instruction, suggesting that the program's flow might change based on a specific condition. The destination of the jump depends on the condition's outcome. For instance, a `jz` (jump if zero) instruction will trigger a jump only if a previous comparison yielded a zero value.

<figure><img src="../../.gitbook/assets/image (63).png" alt=""><figcaption></figcaption></figure>

###

## Graph View

### Function Calls

`IDA` also offers a feature that visualizes the execution flow between functions in an executable via a `call flow graph`. This potent visual tool aids analysts in navigating and understanding the control flow and the interactions among functions.

<figure><img src="../../.gitbook/assets/image (82).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (83).png" alt=""><figcaption></figcaption></figure>

### Navigating Functions

To jump to a new function Right-Click and select "Jump to operand"

<figure><img src="../../.gitbook/assets/image (65).png" alt=""><figcaption></figcaption></figure>

To backtrack to the previous function press the "esc" key or click "Jump Back"

<figure><img src="../../.gitbook/assets/image (66).png" alt=""><figcaption></figcaption></figure>

## Recognizing the Main Function

The **`start`** function is the program's entry point and is generally responsible for setting up the runtime environment before invoking the actual `main` function. Below is the **`start`** function:

<figure><img src="../../.gitbook/assets/image (64).png" alt=""><figcaption><p>start calls two sub_ functions and eventually jumps to loc_40150C (we see this is an exception handler so not main).</p></figcaption></figure>

Once we found the start function our next step is to **search for function calls or jumps that that lead to other functions, as one of them is likely to be main.**

<mark style="color:yellow;">**NOTE:**</mark> sub\_ and loc\_ are autogenerated by IDA

* **`sub_<virtual_address>`** : Subroutine function
* **`loc_<virtual_address>`**: Location in program.



We need to keep scrolling through call functions until we find some juicy nodes. Here we found a **RegOpenKeyEx** that queries for Vmware. This is a common sandbox detection mechanism.&#x20;

The function `RegOpenKeyExA` is a part of the Windows Registry API and is utilized to open a handle to a specified registry key

<figure><img src="../../.gitbook/assets/image (67).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">**NOTE**</mark>: In IDA, <mark style="color:yellow;">`cs`</mark> is a segment register that usually refers to the <mark style="color:yellow;">**code segment**</mark>. When we click on `cs:RegOpenKeyExA` and press `Enter`, this action takes us to the `.idata` section, which includes import-related data and the import address of the function `RegOpenKeyExA`.&#x20;

In this scenario, the `RegOpenKeyExA` function is imported from an external library (advapi32.dll), with its address stored in the `.idata` section for future use.

<figure><img src="../../.gitbook/assets/image (68).png" alt=""><figcaption><p>Notice the .idata section signifying that this is an imported function. Notice the RVA that it is assigned to in the IAT.</p></figcaption></figure>

The line `extrn RegOpenKeyExA:qword` indicates that `RegOpenKeyExA` is an external symbol to be resolved at runtime.&#x20;

This alerts the assembler that the function is defined in another module or library, and the linker will handle the resolution of its address during the linking process.



## Renaming Functions

To rename a function in `IDA`, we should proceed as follows:

* Click the function then, press the `N` key on the keyboard, or right-click and select `Rename` from the context menu.
* Input the new name for the function and press `Enter`.

<figure><img src="../../.gitbook/assets/image (69).png" alt=""><figcaption></figcaption></figure>

## Hunting

### String Obfuscation

Below is a function that implements a **string stack** in combination with presumably a scanf or printf concatenation scheme. It returns: `SOFTWARE\Microsoft\Windows\Current\Version`

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

### Identify Sandbox

The below snippet is a string comparison function calls lea "Load Effective Address" to get the address of the string `C:\\Program Files\\Vmware\VMware Tools.` If **strcmp** returns true the program stops execution with "Sandbox detected" if not it continues to **`sub_402EA0`**

<figure><img src="../../.gitbook/assets/image (70).png" alt=""><figcaption></figcaption></figure>

If the sandbox is evaded the execution flows to **`sub_402EA0`** which is what we describe above. Jumping to the function we discover a URL!

<figure><img src="../../.gitbook/assets/image (71).png" alt=""><figcaption><p>Here is the loot, we discovered a URL!</p></figcaption></figure>

### Classic Process Injection

The below snippet is a classic process injection example. The malware opens a process handle, allocates virtual memory, copies shellcode buffer, and executes a remote thread.

<figure><img src="../../.gitbook/assets/image (76).png" alt=""><figcaption></figcaption></figure>



### Internet Services

Earlier we found the URL of the C2 server. Below is a snippet of the malware using [Wininit](https://learn.microsoft.com/en-us/windows/win32/api/wininet/) to open a connection with the C2 to fetch a shellcode payload. .

<figure><img src="../../.gitbook/assets/image (77).png" alt=""><figcaption></figcaption></figure>



### Cryptocurrency Wallet Addresses

Below is a snippet of a discovered random string.. We can search for it on google to see if it yields any valuable information.

<figure><img src="../../.gitbook/assets/image (80).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (78).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (79).png" alt=""><figcaption></figcaption></figure>
