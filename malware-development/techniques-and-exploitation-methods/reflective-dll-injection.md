---
description: >-
  Reflective DLL injection allows an attacker to inject a DLL into a victim
  process entirely from memory rather than disk. First utilized by Stephen
  Fewer.
---

# Reflective DLL Injection

{% embed url="https://github.com/stephenfewer/ReflectiveDLLInjection/" %}

## Introduction & Preamble

&#x20;_**Reflective DLL's are inherently different than traditional DLLs. In the sense that they are specifically crafted to be executed reflectively, i.e., directly from memory within a target process. They inclu**_

***

_<mark style="color:red;">**NOTE:**</mark>_ Most EDR's have updated their capabilities to detect this default process injection technique utilized by Stephen Fewer along with his Remote Process Execution technique using the CreateRemoteThread API. Furthermore, EDR's also scan newly created Executable memory blocks in remote processes that have PAGE\_EXECUTE\_READWRITE permissions. A way around this is to parse the PE headers and distribute the sections of PE to different locations. So unlike, Stephen Fewer's default reflective loader that allocates the whole memory block to a single page with VirtualAllocEx, we will have separate sections that have different permissions.&#x20;

_<mark style="color:red;">**NOTE:**</mark>_ Also, it's important to note that changing Stephen Fewer's default reflective loader page permissions to PAGE\_EXECUTE\_READ to try to evade EDR will end in an ACCESS\_VIOLATION error. This is because there are several different sections in the PE that have their own permissions (which we cover above).

## How it works&#x20;

* Execution is passed, either via CreateRemoteThread() or a tiny bootstrap shellcode, to the library's ReflectiveLoader function which is an exported function found in the library's export table.
* As the library's image will currently exists in an arbitrary location in memory the ReflectiveLoader will first calculate its own image's current location in memory so as to be able to parse its own headers for use later on.
* The ReflectiveLoader will then parse the host processes kernel32.dll export table in order to calculate the addresses of three functions required by the loader, namely LoadLibraryA, GetProcAddress and VirtualAlloc.
* The ReflectiveLoader will now allocate a continuous region of memory into which it will proceed to load its own image. The location is not important as the loader will correctly relocate the image later on.
* The library's headers and sections are loaded into their new locations in memory.
* The ReflectiveLoader will then process the newly loaded copy of its image's import table, loading any additional library's and resolving their respective imported function addresses.
* The ReflectiveLoader will then process the newly loaded copy of its image's relocation table.
* The ReflectiveLoader will then call its newly loaded image's entry point function, DllMain with DLL\_PROCESS\_ATTACH. The library has now been successfully loaded into memory.
* Finally the ReflectiveLoader will return execution to the initial bootstrap shellcode which called it, or if it was called via CreateRemoteThread, the thread will terminate.



## Implementation

We'll be using Stephen Fewers DLL&#x20;

