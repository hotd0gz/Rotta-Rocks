---
description: >-
  The Import Address Table (IAT) contains information regarding a PE file, such
  as the functions used and the DLLs exporting them. This type of information
  can be used to signature and detect the binary
---

# Hiding & Obfuscating IAT

***

## Dynamic Load at Runtime

It's possible to use `GetProcAddress`, `GetModuleHandle`, and `LoadLibrary` to dynamically load WINAPI functions at runtime.&#x20;

```c
typedef LPVOID (WINAPI* fnVirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

//...
fnVirtualAllocEx pVirtualAllocEx = GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "VirtualAllocEx");
pVirtualAllocEx(...);
```

_<mark style="color:red;">**NOTE:**</mark>_ This is not a very good solution as these functions will appear in the IAT, which by itself is signatured.&#x20;

## Creating Custom WinAPI Functions

For a better overview view:

{% embed url="https://app.gitbook.com/o/KN1jS9mFcRAy3dgznyeV/s/Ntkym7wd1H5AXS7YaAHH/~/changes/73/malware-development/bypassing-av/custom-winapi-functions" %}
Custom WINAPI Functions
{% endembed %}

### Custom GetProcAddress

The `GetProcAddress` WinAPI retrieves the address of an exported function from a specified module handle. The function returns NULL if the function name is not in the specified module handle.

#### How it works

```c
FARPROC GetProcAddress(
  [in] HMODULE hModule,
  [in] LPCSTR  lpProcName
);
```

* `hModule` Base address of the loaded DLL. This is the address where the DLL module is found in the address space of the process.
* `lpcProcName` Retrieving a function's address is found by looping through the exported functions inside the provided DLL and checking if the target function's name exists.

#### Export Table Structure

```c
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```

The relevant members of this structure for this module are the last three.

* `AddressOfFunctions` - Specifies the address of an array of addresses of the exported functions.
* `AddressOfNames` - Specifies the address of an array of addresses of the names of the exported functions.
* `AddressOfNameOrdinals` - Specifies the address of an array of _ordinal numbers_ for the exported functions.

#### Accessing Exported Functions

```c
for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++){
  // Searching for the target exported function 
}
```

### GetProcAddress Code

```c
#include <stdio.h>
#include <wchar.h>
#include <windows.h>


#define TARGET_LIBRARY L"ntdll.dll"
#define TARGET_FUNCTION "NtAllocateVirtualMemory"

int wmain() {

    HMODULE hModule = NULL;
    hModule = LoadLibraryW(TARGET_LIBRARY);
    if (hModule == NULL) {
        wprintf(L"LoadLibrary Failed with Error Code: %d\n", GetLastError());
        return -1;
    }

    // IMPORTANT - Must cast handle address to PBYTE or header parsing will fail
    PBYTE pBase = (PBYTE)hModule;

    wprintf(L"Loaded %s at address: %p\n", TARGET_LIBRARY, pBase);
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if(pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
        wprintf(L"Failed to Get DOS Header");
        return -1;
    }
    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        wprintf(L"Failed to Get NT Header");
        return -1;
    }

    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs->OptionalHeader;
    if (ImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        wprintf(L"Failed to Get Optional Header");
        return -1;
    }

    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    // Getting the function's names array pointer
    PDWORD FunctionNameArray 	= (PDWORD)(pBase + pImgExportDir->AddressOfNames);

    // Getting the function's addresses array pointer
    PDWORD FunctionAddressArray 	= (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);

    // Getting the function's ordinal array pointer
    PWORD  FunctionOrdinalArray 	= (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

    for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++){
        // Getting the name of the function
        CHAR* pFunctionName		= (CHAR*)(pBase + FunctionNameArray[i]);
        // Getting the address of the function
        PVOID pFunctionAddress	= (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);
        // Getting the ordinal of the function
        WORD wFunctionOrdinal = FunctionOrdinalArray[i];
        
        if (strcmp((LPCSTR)TARGET_FUNCTION, pFunctionName) == 0) {
            // Return function address
            return pFunctionAddress;
        }
    }

    return 0;
}
```



***

### Custom GetModuleHandle

The WinAPI function GetModuleHandle retrieves the handle for a specified DLL. The function returns a handle or NULL if the DLL does not exist in the calling process.

```c
HMODULE GetModuleHandle(IN LPCWSTR szModuleName){}
```

#### How GetModuleHandle Works

The HMODULE data type is the base address of the loaded DLL which is where the DLL is located in the memory space of the process. Our replacement function will therefore return the base address of the DLL.

#### Implementation

The first step is access the PEB (Process Environment Block) structure so we can get information on the process & it's loaded modules. The process of retrieving the PEB on 64-Bit & 32-Bit systems are different, the pointer to the PEB is found in the TEB (Thread Environment Block) structure.



#### Retrieving PEB on 64-Bit System

