---
description: >-
  Using private memory allocation functions are heavily monitored by AV/EDR.
  Using mapped memory can help circumvent detection.
---

# Memory Mapping



***

## CreateFileMapping

[CreateFileMapping](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga) allows a process to create a virtual memory space that maps to the contents of a file on disk or to another memory location. The function returns a handle to the file mapping object.

```c
HANDLE CreateFileMappingA(
  [in]           HANDLE                hFile,
  [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes,     // Not Required - NULL
  [in]           DWORD                 flProtect,
  [in]           DWORD                 dwMaximumSizeHigh,           // Not Required - NULL
  [in]           DWORD                 dwMaximumSizeLow,
  [in, optional] LPCSTR                lpName                       // Not Required - NULL   
);
```

`hFile` - A handle to a file from which to create a file mapping handle.

`flProtect` - Specifies the page protection of the file mapping object. (`PAGE_EXECUTE_READWRITE)`

`dwMaximumSizeLow` - The size of the file mapping handle returned. (Size of payload)

## M**apViewOfFile**

[MapViewOfFile](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile) maps a view of a file mapping object into the address space of a process.&#x20;

```c
LPVOID MapViewOfFile(
  [in] HANDLE     hFileMappingObject,
  [in] DWORD      dwDesiredAccess,
  [in] DWORD      dwFileOffsetHigh,           // Not Required - NULL
  [in] DWORD      dwFileOffsetLow,            // Not Required - NULL
  [in] SIZE_T     dwNumberOfBytesToMap
);
```

* `hFileMappingObject` - The returned handle from the `CreateFileMapping` WinAPI, which is the file mapping object.
* `dwDesiredAccess` - The type of access to a file mapping object, which determines the page protection of the page created. Should correspond w/ the flProtect attributes in CreateFileMapping.
* `dwNumberOfBytesToMap` - The size of the payload.

<pre class="language-c"><code class="lang-c"><strong>#include &#x3C;stdio.h>
</strong><strong>#include &#x3C;wchar.h>
</strong><strong>#include &#x3C;windows.h>
</strong><strong>
</strong><strong>
</strong><strong>const char pPaylaod[] = [0x00 0x01 0x02 0x03 0x04]
</strong><strong>
</strong><strong>int wmain() {
</strong><strong>	BOOL   bSTATE         = TRUE;
</strong>	HANDLE hFile          = NULL;
	PVOID  pMapAddress    = NULL;


	// Create a file mapping handle with RWX memory permissions
	// This does not allocate RWX view of file unless it is specified in the subsequent MapViewOfFile call  
	hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);
	if (hFile == NULL) {
		printf("[!] CreateFileMapping Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}

	// Maps the view of the payload to the memory 
	pMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE | FILE_MAP_EXECUTE, NULL, NULL, sPayloadSize);
	if (pMapAddress == NULL) {
		printf("[!] MapViewOfFile Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}
	
    // Copying the payload to the mapped memory
	memcpy(pMapAddress, pPayload, sPayloadSize);
}
</code></pre>

_**To Map Memory in Remote Process We can use the following:**_

## MapViewOfFile2

[MapViewOfFile2](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile2) is used to map memory in a remote process.

```c
PVOID MapViewOfFile2(
  [in]           HANDLE  FileMappingHandle,
  [in]           HANDLE  ProcessHandle,
  [in]           ULONG64 Offset,
  [in, optional] PVOID   BaseAddress,
  [in]           SIZE_T  ViewSize,
  [in]           ULONG   AllocationType,
  [in]           ULONG   PageProtection
);
```

## MapViewOfFile3

[MapViewOfFile3](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile3) is used to map memory in a remote process.

```c
PVOID MapViewOfFile3(
  [in]                HANDLE                 FileMapping,
  [in]                HANDLE                 Process,
  [in, optional]      PVOID                  BaseAddress,
  [in]                ULONG64                Offset,
  [in]                SIZE_T                 ViewSize,
  [in]                ULONG                  AllocationType,
  [in]                ULONG                  PageProtection,
  [in, out, optional] MEM_EXTENDED_PARAMETER *ExtendedParameters,
  [in]                ULONG                  ParameterCount
);
```

## UnmapViewOfFile

[UnmapViewOfFile](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile) is used to unmap previously mapped memory. This should be called on cleanup.

## UnmapViewOfFileEx

This is an extended version of [UnmapViewOfFile](https://learn.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-unmapviewoffile) that takes an additional flags parameter.

## UnmapViewOfFile2

[UnmapViewOfFile2](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile2) Unmaps a previously mapped view of a file or a pagefile-backed section.
