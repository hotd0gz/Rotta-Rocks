---
description: >-
  Reflective DLL injection allows an attacker to inject a DLL into a victim
  process entirely from memory rather than disk. First utilized by Stephen
  Fewer.
---

# Reflective DLL Injection

{% embed url="https://github.com/stephenfewer/ReflectiveDLLInjection/" %}

## Introduction

&#x20;_**Reflective DLL's are inherently different than traditional DLLs. In the sense that they are specifically crafted to be executed reflectively. I.E executing themselves.**_

***

Most EDR's have updated their capabilities to detect this default process injection technique utilized by Stephen Fewer along with his Remote Process Execution technique using the CreateRemoteThread API.&#x20;

EDR's also scan newly created Executable memory blocks in remote processes that have PAGE\_EXECUTE\_READWRITE permissions. A way around this is to parse the PE headers and distribute the sections of PE to different locations.&#x20;

_<mark style="color:red;">**NOTE:**</mark>_ Also, it's important to note that changing Stephen Fewer's default reflective loader page permissions to PAGE\_EXECUTE\_READ to try to evade EDR will end in an ACCESS\_VIOLATION error. This is because there are several different sections in the PE that have their own permissions (which we cover above).



## Reflective DLL Injection

A reflective DLL exports a special function to inject itself when it's called. <mark style="color:red;">This function cannot include WinAPI functions or global variables</mark> as they rely on offsets set by the compiler which become invalid.

(<mark style="color:yellow;">Custom</mark> `GetModuleHandle` <mark style="color:yellow;">and</mark> `GetProcAddress` <mark style="color:yellow;">functions are required to resolve WinAPIs used in the</mark> `ReflectiveFunction` <mark style="color:yellow;">function.</mark> Make sure to include string hashing.)





## Building Reflective DLL



### Special Reflective Loader Function

The bread and butter of reflective DLL injection lies in the reflective loader function inside the DLL. This is responsible for patching IAT, fixing relocations, and executing the DLL's entrypoint.

```c
// Create Exported caller function. Will be brute-forced by Inject.exe
__declspec(dllexport) VOID ReflectiveFunction() {
    // Sauce goes here :)
}

```

This is the function we will call in inject.exe once the DLL is loaded.

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>



### Brute forcing DLL Base address (from dll)

One thing I think is very interesting about the Special Reflective Function is the use of bruteforcing the DLL's base address from within the DLL.

Below we get a pointer to ReflectiveFunction (from within ReflectiveFunction!) and traverse back until we get a valid DOS header (signifying the base address of the DLL image). Very cool stuff.

```c
extern __declspec(dllexport) BOOL ReflectiveFunction() {

		// Brute forcing ReflectiveDllLdr.dll's base address, starting at ReflectiveFunction's address
	uTmpAddress = (ULONG_PTR)ReflectiveFunction;

	do
	{
		pImgDosHdr = (PIMAGE_DOS_HEADER)uTmpAddress;

		// Check if the current uTmpAddress is a DOS header
		if (pImgDosHdr->e_magic == IMAGE_DOS_SIGNATURE)
		{
			// To terminate false positives - we do another check by retrieving the NT header and checking its signature as well
			pImgNtHdrs = (PIMAGE_NT_HEADERS)(uTmpAddress + pImgDosHdr->e_lfanew);

			if (pImgNtHdrs->Signature == IMAGE_NT_SIGNATURE) {
				// If valid, the current uTmpAddress is ReflectiveDllLdr.dll's base address 
				uReflectiveDllModule = uTmpAddress;
				break;
			}
		}
		// Keep decrementing to reach the DLL's base address
		uTmpAddress--;

	} while (TRUE);
}
```

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>



### Patching Import Address Table (IAT)

Now that we have the base address of the DLL (see above) we can patch the IAT.





## References

### Write-up by Stephen Fewer

{% embed url="https://www.exploit-db.com/docs/english/13007-reflective-dll-injection.pdf" %}
